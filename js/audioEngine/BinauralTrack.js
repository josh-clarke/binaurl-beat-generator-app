/**
 * BinauralTrack.js - Binaural beat track implementation
 * 
 * This class extends the base Track class to create binaural beats,
 * which are generated by playing slightly different frequencies
 * in each ear to create a perceived beat frequency.
 */

import Track from './Track.js';

export default class BinauralTrack extends Track {
  /**
   * Create a new BinauralTrack
   * @param {AudioContext} audioContext - The Web Audio API context
   * @param {Object} options - Configuration options
   * @param {number} options.carrierFrequency - Base frequency in Hz (default: 200)
   * @param {number} options.beatFrequency - Beat frequency in Hz (default: 10)
   * @param {number} options.volume - Initial volume (0-1)
   */
  constructor(audioContext, options = {}) {
    // Set track type for offline rendering
    options.type = 'binaural';
    
    super(audioContext, options);
    
    // Set default values if not provided
    this.carrierFrequency = options.carrierFrequency || 200;
    this.beatFrequency = options.beatFrequency || 10;
    
    // Create oscillators for left and right channels
    this.leftOscillator = null;
    this.rightOscillator = null;
    
    // Create stereo panner for channel separation
    this.leftPanner = this.audioContext.createStereoPanner();
    this.rightPanner = this.audioContext.createStereoPanner();
    
    // Set hard left/right panning
    this.leftPanner.pan.value = -1;  // Full left
    this.rightPanner.pan.value = 1;  // Full right
    
    // Connect panners to the gain node
    this.leftPanner.connect(this.gainNode);
    this.rightPanner.connect(this.gainNode);
    
    // Calculate the left and right frequencies
    this._calculateFrequencies();
  }
  
  /**
   * Calculate left and right ear frequencies based on carrier and beat frequencies
   * @private
   */
  _calculateFrequencies() {
    // The carrier frequency is the average of the two frequencies
    // The beat frequency is the difference between the two frequencies
    this.leftFrequency = this.carrierFrequency - (this.beatFrequency / 2);
    this.rightFrequency = this.carrierFrequency + (this.beatFrequency / 2);
  }
  
  /**
   * Create and configure oscillators
   * @private
   */
  _createOscillators() {
    // Create oscillators
    this.leftOscillator = this.audioContext.createOscillator();
    this.rightOscillator = this.audioContext.createOscillator();
    
    // Set oscillator types (sine wave is best for binaural beats)
    this.leftOscillator.type = 'sine';
    this.rightOscillator.type = 'sine';
    
    // Set frequencies
    this.leftOscillator.frequency.value = this.leftFrequency;
    this.rightOscillator.frequency.value = this.rightFrequency;
    
    // Connect oscillators to panners
    this.leftOscillator.connect(this.leftPanner);
    this.rightOscillator.connect(this.rightPanner);
  }
  
  /**
   * Start the binaural beat with fade-in
   */
  start() {
    if (this.isPlaying) return;
    
    // Create new oscillators
    this._createOscillators();
    
    // Start oscillators
    const now = this.audioContext.currentTime;
    this.leftOscillator.start(now);
    this.rightOscillator.start(now);
    
    // Call the parent class start method for fade-in
    super.start();
  }
  
  /**
   * Stop the binaural beat with fade-out
   * @return {Promise} Resolves when the track has stopped
   */
  async stop() {
    if (!this.isPlaying) return Promise.resolve();
    
    // Apply fade-out using parent method
    await super.stop();
    
    // Stop and clean up oscillators
    const now = this.audioContext.currentTime;
    
    if (this.leftOscillator) {
      this.leftOscillator.stop(now);
      this.leftOscillator.disconnect();
      this.leftOscillator = null;
    }
    
    if (this.rightOscillator) {
      this.rightOscillator.stop(now);
      this.rightOscillator.disconnect();
      this.rightOscillator = null;
    }
    
    return Promise.resolve();
  }
  
  /**
   * Update binaural track parameters
   * @param {Object} params - Parameters to update
   * @param {number} params.carrierFrequency - New carrier frequency in Hz
   * @param {number} params.beatFrequency - New beat frequency in Hz
   * @param {number} params.volume - New volume level (0-1)
   */
  update(params = {}) {
    let frequenciesChanged = false;
    
    // Update carrier frequency if provided
    if (typeof params.carrierFrequency === 'number') {
      this.carrierFrequency = params.carrierFrequency;
      frequenciesChanged = true;
    }
    
    // Update beat frequency if provided
    if (typeof params.beatFrequency === 'number') {
      this.beatFrequency = params.beatFrequency;
      frequenciesChanged = true;
    }
    
    // If frequencies changed, recalculate and update oscillators if playing
    if (frequenciesChanged) {
      this._calculateFrequencies();
      
      if (this.isPlaying && this.leftOscillator && this.rightOscillator) {
        // Apply smooth transition to new frequencies
        const now = this.audioContext.currentTime;
        this.leftOscillator.frequency.setValueAtTime(this.leftOscillator.frequency.value, now);
        this.leftOscillator.frequency.linearRampToValueAtTime(this.leftFrequency, now + 0.1);
        
        this.rightOscillator.frequency.setValueAtTime(this.rightOscillator.frequency.value, now);
        this.rightOscillator.frequency.linearRampToValueAtTime(this.rightFrequency, now + 0.1);
      }
    }
    
    // Call parent update for common parameters like volume
    super.update(params);
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    if (this.isPlaying) {
      this.stop();
    }
    
    // Disconnect panners
    this.leftPanner.disconnect();
    this.rightPanner.disconnect();
    
    // Call parent dispose
    super.dispose();
  }
}